/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * java mavlink generator tool. It should not be modified by hand.
 */
        
package com.MAVLink;

import java.io.Serializable;
import com.MAVLink.Messages.MAVLinkPayload;
import com.MAVLink.Messages.MAVLinkMessage;
import com.MAVLink.task1.CRC;

import com.MAVLink.task1.*;

/**
* Common interface for all MAVLink Messages
* Packet Anatomy
* This is the anatomy of one packet. It is inspired by the CAN and SAE AS-4 standards.

* Byte Index  Content              Value       Explanation
* 0            Packet start sign  v1.0: 0xFE   Indicates the start of a new packet.  (v0.9: 0x55)
* 1            Payload length      0 - 255     Indicates length of the following payload.
* 2            Packet sequence     0 - 255     Each component counts up his send sequence. Allows to detect packet loss
* 3            System ID           1 - 255     ID of the SENDING system. Allows to differentiate different MAVs on the same network.
* 4            Component ID        0 - 255     ID of the SENDING component. Allows to differentiate different components of the same system, e.g. the IMU and the autopilot.
* 5            Message ID          0 - 255     ID of the message - the id defines what the payload means and how it should be correctly decoded.
* 6 to (n+6)   Payload             0 - 255     Data of the message, depends on the message id.
* (n+7)to(n+8) Checksum (low byte, high byte)  ITU X.25/SAE AS-4 hash, excluding packet start sign, so bytes 1..(n+6) Note: The checksum also includes MAVLINK_CRC_EXTRA (Number computed from message fields. Protects the packet from decoding a different version of the same packet but with different variables).

* The checksum is the same as used in ITU X.25 and SAE AS-4 standards (CRC-16-CCITT), documented in SAE AS5669A. Please see the MAVLink source code for a documented C-implementation of it. LINK TO CHECKSUM
* The minimum packet length is 8 bytes for acknowledgement packets without payload
* The maximum packet length is 263 bytes for full payload
*
*/
public class MAVLinkPacket implements Serializable {
    private static final long serialVersionUID = 2095947771227815314L;

    public static final int MAVLINK_STX = 253;

    public static final int MAVLINK_STX_MAVLINK1 = 254;

    public enum Protocol {
        PROTOCOL_0_9,
        PROTOCOL_1_0,
        PROTOCOL_2_0
    }

    /**
    * protocol version
    */
    public Protocol protocol;

    /**
    * Message length. NOT counting STX, LENGTH, SEQ, INCOMPAT_FLAGS, COMPAT_FLAGS, SYSID, COMPID, MSGID, CRC1 and CRC2
    */
    public final int len;

    /**
    * Message sequence
    */
    public int seq;

    /**
    * Flags that must be understood
    */
    public int incompat_flags;

    /**
    * Flags that can be ignored if not understood
    */
    public int compat_flags;

    /**
    * ID of the SENDING system. Allows to differentiate different MAVs on the
    * same network.
    */
    public int sysid;

    /**
    * ID of the SENDING component. Allows to differentiate different components
    * of the same system, e.g. the IMU and the autopilot.
    */
    public int compid;

    /**
    * ID of the message - the id defines what the payload means and how it
    * should be correctly decoded.
    */
    public int msgid;

    /**
    * Data of the message, depends on the message id.
    */
    public MAVLinkPayload payload;

    /**
    * crc extra value of the message.
    */
    public int crc_extra;

    /**
    * ITU X.25/SAE AS-4 hash, excluding packet start sign, so bytes 1..(n+6)
    * Note: The checksum also includes MAVLINK_CRC_EXTRA (Number computed from
    * message fields. Protects the packet from decoding a different version of
    * the same packet but with different variables).
    */
    public CRC crc;

    public MAVLinkPacket(int payloadLength) {
        protocol = Protocol.PROTOCOL_1_0;
        incompat_flags = 0;
        compat_flags = 0;
        len = payloadLength;
        payload = new MAVLinkPayload(payloadLength);
        crc_extra = -1;
    }

    /**
    * Set the MAVLink protocol for this packet.
    */
    public void setProtocol(Protocol protocol) {
        this.protocol = protocol;
    }

    /**
    * Check if the size of the Payload is equal to the "len" byte.
    */
    public boolean payloadIsFilled() {
        return payload.size() >= len;
    }

    /**
    * Update CRC for this packet.
    */
    public void generateCRC() {
        generateCRC(payload.size());
    }

    /**
    * Update CRC for this packet with given trimmed payload length.
    */
    private void generateCRC(int payloadSize){
        if(crc == null){
            crc = new CRC();
        }
        else{
            crc.start_checksum();
        }
        
        crc.update_checksum(len);
        if (protocol == Protocol.PROTOCOL_2_0) {
            crc.update_checksum(incompat_flags);
            crc.update_checksum(compat_flags);
        }
        crc.update_checksum(seq);
        crc.update_checksum(sysid);
        crc.update_checksum(compid);
        crc.update_checksum(msgid);
        if (protocol == Protocol.PROTOCOL_2_0) {
            crc.update_checksum(msgid >> 8);
            crc.update_checksum(msgid >> 16);
        }

        payload.resetIndex();

        for (int i = 0; i < payloadSize; i++) {
            crc.update_checksum(payload.getByte());
        }

        if (crc_extra != -1) {
            crc.update_checksum(crc_extra);
        } else {
            crc_extra = crc.finish_checksum(msgid);
        }
    }

    /**
    * Encode this packet in MAVLink1 for transmission.
    *
    * @return Array with bytes to be transmitted
    */
    private byte[] encodeMavlink1Packet() {
        byte[] buffer = new byte[6 + len + 2];

        int i = 0;
        buffer[i++] = (byte) MAVLINK_STX_MAVLINK1;
        buffer[i++] = (byte) len;
        buffer[i++] = (byte) seq;
        buffer[i++] = (byte) sysid;
        buffer[i++] = (byte) compid;
        buffer[i++] = (byte) msgid;

        final int payloadSize = payload.size();
        for (int j = 0; j < payloadSize; j++) {
            buffer[i++] = payload.payload.get(j);
        }

        generateCRC();
        buffer[i++] = (byte) (crc.getLSB());
        buffer[i++] = (byte) (crc.getMSB());
        return buffer;
    }

    /**
    * Trim payload of any trailing zero bytes.
    *
    * @return Length of bytes to be transmitted
    */
    int trimPayload() {
        for (int i = payload.size(); i > 0; i--) {
            if (payload.get(i - 1) != 0) {
                return i;
            }
        }
        return 0;
    }

    /**
    * Encode this packet in MAVLink2 for transmission.
    *
    * @return Array with bytes to be transmitted
    */
    private byte[] encodeMavlink2Packet() {
        int length = trimPayload();

        byte[] buffer = new byte[10 + length + 2];

        int i = 0;
        buffer[i++] = (byte) MAVLINK_STX;
        buffer[i++] = (byte) length;
        buffer[i++] = (byte) incompat_flags;
        buffer[i++] = (byte) compat_flags;
        buffer[i++] = (byte) seq;
        buffer[i++] = (byte) sysid;
        buffer[i++] = (byte) compid;
        buffer[i++] = (byte) (msgid & 0xff);
        buffer[i++] = (byte) ((msgid >> 8) & 0xff);
        buffer[i++] = (byte) ((msgid >> 16) & 0xff);

        for (int j = 0; j < length; j++) {
            buffer[i++] = payload.payload.get(j);
        }

        generateCRC(length);
        buffer[i++] = (byte) (crc.getLSB());
        buffer[i++] = (byte) (crc.getMSB());
        return buffer;
    }

    /**
    * Encode this packet for transmission;
    *
    * @return Array with bytes to be transmitted
    */
    public byte[] encodePacket() {
        if (protocol == Protocol.PROTOCOL_2_0) {
            return encodeMavlink2Packet();
        } else {
            return encodeMavlink1Packet();
        }
    }

    /**
    * Unpack the data in this packet and return a MAVLink message
    *
    * @return MAVLink message decoded from this packet
    */
    public MAVLinkMessage unpack() {
        switch (msgid) {
                         
            case msg_task1_types.MAVLINK_MSG_ID_TASK1_TYPES:
                return new msg_task1_types(this);
            
            
            default:
                return null;
        }
    }

}
        
        